{"meta":{"title":"Phoenix","subtitle":null,"description":"A Simple and Card UI Design theme for Hexo","author":"Lewis","url":"https://butterfly.js.org","root":"/"},"pages":[{"title":"Gallery","date":"2019-10-24T14:23:55.000Z","updated":"2021-03-08T14:35:33.000Z","comments":false,"path":"Gallery/index.html","permalink":"https://butterfly.js.org/Gallery/","excerpt":"","text":"壁紙 收藏的一些壁紙 漫威 關於漫威的圖片 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"示例","date":"2018-06-07T14:17:49.000Z","updated":"2021-03-08T14:35:33.000Z","comments":true,"path":"link/index.html","permalink":"https://butterfly.js.org/link/","excerpt":"","text":"如果你想把自己的網頁也新增到示例頁面，請 確保你使用 Butterfly 主題 點擊這個鏈接 按要求新增內容 點擊下面的 Commit changes ，合併到 butterfly.js.org 倉庫"},{"title":"留言板","date":"2019-04-14T10:30:38.000Z","updated":"2021-03-08T14:35:33.000Z","comments":true,"path":"messageboard/index.html","permalink":"https://butterfly.js.org/messageboard/","excerpt":"","text":"Troubleshooting any problem without the error log is like driving with your eyes closed. 在沒有錯誤日誌的情況下診斷任何問題無異於閉眼開車 反饋 Bug 或者詢問使用問題，最好去 issues 發帖 在你反饋 Bug 或者詢問使用問題之前，請注意 請確保你已經看了安裝文檔 請確保你已經看了 主題Q&amp;A 如果運行期間並無報錯，但是預覽時出現問題。請在瀏覽器打開該網頁的情況下，按 F12 進入開發人員工具，切換到 Console 界面。如有報錯，請試着解決。或者在提問題之前附上報錯截圖。 詳細描述遇到的問題，附上相關的報錯/截圖/網址 請禮貌用語"},{"title":"分類","date":"2018-06-07T14:17:49.000Z","updated":"2021-03-08T14:35:33.000Z","comments":false,"path":"categories/index.html","permalink":"https://butterfly.js.org/categories/","excerpt":"","text":""},{"title":"標籤","date":"2018-06-07T14:15:37.000Z","updated":"2021-03-08T14:35:33.000Z","comments":false,"path":"tags/index.html","permalink":"https://butterfly.js.org/tags/","excerpt":"","text":""},{"title":"ohmygirl","date":"2019-12-25T15:42:01.000Z","updated":"2021-03-08T14:35:33.000Z","comments":false,"path":"Gallery/ohmygirl/index.html","permalink":"https://butterfly.js.org/Gallery/ohmygirl/","excerpt":"","text":""},{"title":"自言自語","date":"2020-09-15T16:58:58.000Z","updated":"2021-03-08T14:35:33.000Z","comments":false,"path":"talking/index.html","permalink":"https://butterfly.js.org/talking/","excerpt":"","text":""},{"title":"壁紙","date":"2019-12-25T07:04:35.000Z","updated":"2021-03-08T14:35:33.000Z","comments":false,"path":"Gallery/wallpaper/index.html","permalink":"https://butterfly.js.org/Gallery/wallpaper/","excerpt":"","text":""},{"title":"Marvel","date":"2019-12-25T15:29:25.000Z","updated":"2021-03-08T14:35:33.000Z","comments":false,"path":"Gallery/marvel/index.html","permalink":"https://butterfly.js.org/Gallery/marvel/","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-03-16T10:36:08.814Z","updated":"2021-03-16T07:30:01.095Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://butterfly.js.org/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2020-12-22T12:00:07.000Z","updated":"2021-03-16T07:30:01.105Z","comments":true,"path":"posts/d95d7e09/","link":"","permalink":"https://butterfly.js.org/posts/d95d7e09/","excerpt":"","text":"1.音频组件控制uni.createInnerAudioContext()创建并返回内部 audio 上下文 innerAudioContext 对象。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 QQ小程序 √ √ √ 1.23.4+ √ √ √ innerAudioContext 对象的属性列表 属性 类型 说明 只读 平台差异说明 src String 音频的数据链接，用于直接播放。 否 startTime Number 开始播放的位置（单位：s），默认 0 否 autoplay Boolean 是否自动开始播放，默认 false 否 H5端部分浏览器不支持 loop Boolean 是否循环播放，默认 false 否 obeyMuteSwitch Boolean 是否遵循系统静音开关，当此参数为 false 时，即使用户打开了静音开关，也能继续发出声音，默认值 true 否 微信小程序、百度小程序、字节跳动小程序 duration Number 当前音频的长度（单位：s），只有在当前有合法的 src 时返回，需要在onCanplay中获取 是 currentTime Number 当前音频的播放位置（单位：s），只有在当前有合法的 src 时返回，时间不取整，保留小数点后 6 位 是 paused Boolean 当前是是否暂停或停止状态，true 表示暂停或停止，false 表示正在播放 是 buffered Number 音频缓冲的时间点，仅保证当前播放时间点到此时间点内容已缓冲。 是 volume Number 音量。范围 0~1。 否 innerAudioContext 对象的方法列表 方法 参数 说明 play 播放（H5端部分浏览器需在用户交互时进行） pause 暂停 stop 停止 seek position 跳转到指定位置，单位 s destroy 销毁当前实例 onCanplay callback 音频进入可以播放状态，但不保证后面可以流畅播放 onPlay callback 音频播放事件 onPause callback 音频暂停事件 onStop callback 音频停止事件 onEnded callback 音频自然播放结束事件 onTimeUpdate callback 音频播放进度更新事件 onError callback 音频播放错误事件 onWaiting callback 音频加载中事件，当音频因为数据不足，需要停下来加载时会触发 onSeeking callback 音频进行 seek 操作事件 onSeeked callback 音频完成 seek 操作事件 offCanplay callback 取消监听 onCanplay 事件 offPlay callback 取消监听 onPlay 事件 offPause callback 取消监听 onPause 事件 offStop callback 取消监听 onStop 事件 offEnded callback 取消监听 onEnded 事件 offTimeUpdate callback 取消监听 onTimeUpdate 事件 offError callback 取消监听 onError 事件 offWaiting callback 取消监听 onWaiting 事件 offSeeking callback 取消监听 onSeeking 事件 offSeeked callback 取消监听 onSeeked 事件 errCode 说明 errCode 说明 10001 系统错误 10002 网络错误 10003 文件错误 10004 格式错误 -1 未知错误 支持格式 格式 iOS Android flac x √ m4a √ √ ogg x √ ape x √ amr x √ wma x √ wav √ √ mp3 √ √ mp4 x √ aac √ √ aiff √ x caf √ x 示例 12345678910const innerAudioContext &#x3D; uni.createInnerAudioContext();innerAudioContext.autoplay &#x3D; true;innerAudioContext.src &#x3D; &#39;https:&#x2F;&#x2F;vkceyugu.cdn.bspapp.com&#x2F;VKCEYUGU-hello-uniapp&#x2F;2cc220e0-c27a-11ea-9dfb-6da8e309e0d8.mp3&#39;;innerAudioContext.onPlay(() &#x3D;&gt; &#123; console.log(&#39;开始播放&#39;);&#125;);innerAudioContext.onError((res) &#x3D;&gt; &#123; console.log(res.errMsg); console.log(res.errCode);&#125;); tips 如需音频的倍速播放，可通过video的倍速播放替代实现。插件市场有封装好的插件音频倍速播放 如果需要带ui的音频播放器样式，可以在插件市场搜索相关插件 2.视频组件控制uni.createVideoContext(videoId, this)创建并返回 video 上下文 videoContext 对象。在自定义组件下，第二个参数传入组件实例this，以操作组件内 &lt;video&gt; 组件。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 QQ小程序 √ √ √ 基础库版本&gt;=1.10.0 √ √ √ videoContext 对象的方法列表 方法 参数 说明 平台差异说明 play 无 播放 pause 无 暂停 seek position 跳转到指定位置，单位 s stop 停止视频 微信小程序 sendDanmu danmu 发送弹幕，danmu 包含两个属性 text, color playbackRate rate 设置倍速播放，支持的倍率有 0.5/0.8/1.0/1.25/1.5。微信基础库2.6.3 起支持 2.0 倍速 requestFullScreen 无 进入全屏，可传入{direction}参数，详见 video 组件文档 exitFullScreen 无 退出全屏 showStatusBar 无 显示状态栏，仅在iOS全屏下有效 微信小程序、百度小程序、QQ小程序 hideStatusBar 无 隐藏状态栏，仅在iOS全屏下有效 微信小程序、百度小程序、QQ小程序 注意： app-nvue 平台 2.2.5+ 支持 uni.createVideoContext(videoId, this) app-nvue 平台 2.2.5以下使用本API，需同时设置组件属性id和ref &lt;video id=&quot;video1&quot; ref=&quot;video1&quot;&gt;&lt;/video&gt;，或者直接使用 ref，例如 this.$refs.video1 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;view&gt; &lt;view class&#x3D;&quot;page-body&quot;&gt; &lt;view class&#x3D;&quot;page-section&quot;&gt; &lt;video id&#x3D;&quot;myVideo&quot; src&#x3D;&quot;http:&#x2F;&#x2F;img.cdn.qiniu.dcloud.net.cn&#x2F;wap2appvsnative.mp4&quot; @error&#x3D;&quot;videoErrorCallback&quot; :danmu-list&#x3D;&quot;danmuList&quot; enable-danmu danmu-btn controls&gt;&lt;&#x2F;video&gt; &lt;view class&#x3D;&quot;uni-list&quot;&gt; &lt;view class&#x3D;&quot;uni-list-cell&quot;&gt; &lt;view&gt; &lt;view class&#x3D;&quot;uni-label&quot;&gt;弹幕内容&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;view class&#x3D;&quot;uni-list-cell-db&quot;&gt; &lt;input @blur&#x3D;&quot;bindInputBlur&quot; class&#x3D;&quot;uni-input&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;在此处输入弹幕内容&quot; &#x2F;&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;view class&#x3D;&quot;btn-area&quot;&gt; &lt;button @tap&#x3D;&quot;bindSendDanmu&quot; class&#x3D;&quot;page-body-button&quot; formType&#x3D;&quot;submit&quot;&gt;发送弹幕&lt;&#x2F;button&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt;&lt;&#x2F;template&gt;export default &#123; data() &#123; return &#123; title: &#39;video&#39;, src: &#39;&#39;, inputValue: &#39;&#39;, danmuList: [&#123; text: &#39;第 1s 出现的弹幕&#39;, color: &#39;#ff0000&#39;, time: 1 &#125;, &#123; text: &#39;第 3s 出现的弹幕&#39;, color: &#39;#ff00ff&#39;, time: 3 &#125; ] &#125; &#125;, onReady: function (res) &#123; this.videoContext &#x3D; uni.createVideoContext(&#39;myVideo&#39;) &#125;, methods: &#123; bindInputBlur: function (e) &#123; this.inputValue &#x3D; e.target.value &#125;, bindButtonTap: function () &#123; var that &#x3D; this uni.chooseVideo(&#123; sourceType: [&#39;album&#39;, &#39;camera&#39;], maxDuration: 60, camera: [&#39;front&#39;, &#39;back&#39;], success: function (res) &#123; this.src &#x3D; res.tempFilePath &#125; &#125;) &#125;, bindSendDanmu: function () &#123; this.videoContext.sendDanmu(&#123; text: this.inputValue, color: this.getRandomColor() &#125;) &#125;, videoErrorCallback: function (e) &#123; console.log(&#39;视频错误信息:&#39;) console.log(e.target.errMsg) &#125;, getRandomColor: function () &#123; const rgb &#x3D; [] for (let i &#x3D; 0; i &lt; 3; ++i) &#123; let color &#x3D; Math.floor(Math.random() * 256).toString(16) color &#x3D; color.length &#x3D;&#x3D; 1 ? &#39;0&#39; + color : color rgb.push(color) &#125; return &#39;#&#39; + rgb.join(&#39;&#39;) &#125; &#125;&#125; 3.相机组件控制uni.createCameraContext()创建并返回 camera 组件的上下文 cameraContext 对象。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 QQ小程序 x x √ x √ x √ 本API为 camera 组件配套的js API，与 camera 组件的平台兼容性相同，可实现非全屏摄像头。App端可通过plus.camera实现全屏摄像头。 cameraContext 对象的方法列表 方法 参数 说明 takePhoto Object 拍照，可指定质量，成功则返回图片路径。 setZoom Object 设置缩放级别 微信小程序 2.10.0+ 支持 startRecord Object 开始录像 stopRecord Object 结束录像，成功则返回封面与视频。 onCameraFrame Function 获取 Camera 实时帧数据。仅微信小程序平台支持，规范详情 cameraContext.takePhototakePhoto 的 Object 参数列表： 参数 类型 必填 说明 quality String 否 成像质量，值为high（高质量）、normal（普通质量）、low（低质量），默认normal success Function 否 接口调用成功的回调函数 ，返回照片文件的临时路径，res = { tempImagePath } fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） cameraContext.setZoomsetZoom 的 Object 参数列表： 参数 类型 必填 说明 zoom String 是 缩放级别，范围[1, maxZoom]。zoom 可取小数，精确到小数后一位。maxZoom 可在 @initdone 返回值中获取。 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） cameraContext.startRecordstartRecord 的 Object 参数列表： 参数 类型 必填 说明 timeoutCallback Function 否 接超过30s或页面 onHide 时会结束录像 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） cameraContext.stopRecordstopRecord 的 Object 参数列表： 参数 类型 默认值 必填 说明 compressed Boolean false 否 启动视频压缩，压缩效果同 chooseVideo ,微信小程序 2.10.0+ 支持｜ success Function 否 接口调用成功的回调函数 ，返回封面与视频的临时路径，res = { tempThumbPath, tempVideoPath }。 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 注意 App下实现OCR等证件识别等需求，可在插件市场获取原生插件，https://ext.dcloud.net.cn/plugin?id=135 微信小程序下实现OCR等证件识别等需求，插件市场也有封装，搜索 ocr 可见。 可以通过用户授权API来判断用户是否给应用授予摄像头的访问权限https://uniapp.dcloud.io/api/other/authorize 4.直播组件控制uni.createLivePlayerContext(livePlayerId, this)创建 live-player 上下文 livePlayerContext 对象。注意是直播的播放而不是推流。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 QQ小程序 见下 x √ x √ x √ App平台的直播播放，不使用此API，而直接使用video的API。 参数说明 参数 说明 平台差异说明 livePlayerId &lt;live-player&gt; 组件 id this 在自定义组件下，当前组件实例的 this，以操作组件内 &lt;live-player&gt; 组件 微信小程序 livePlayerContext 对象的方法列表： 方法 参数 说明 play Object 播放 stop Object 停止 mute Object 静音 pause Object 暂停 resume Object 恢复 requestFullScreen Object 进入全屏 exitFullScreen Object 退出全屏 requestFullScreen 的 Object 参数列表： 参数 类型 必填 说明 direction Number 是 设置全屏时的方向，有效值为 0（正常竖向）, 90（屏幕逆时针90度）, -90（屏幕顺时针90度）。 success Function 否 接口调用成功的回调函数。 fail Function 否 接口调用失败的回调函数。 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）。 其他方法的 Object 参数列表： 参数 类型 必填 说明 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.createLivePusherContext(livePusherId, this)创建 live-pusher 上下文 livePusherContext 对象。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 QQ小程序 见下 x √ x x x √ app-nvue 平台 2.2.5+ 支持 uni.createLivePusherContext(livePusherId, this) app-nvue 平台 2.2.5以下，需要同时设置组件属性id和ref &lt;live-pusher id=&quot;livepusher1&quot; ref=&quot;livepusher1&quot;&gt;&lt;/live-pusher&gt;，或者直接使用 ref，例如 this.$refs.livepusher1 app-vue 平台，需要编写条件编译代码，使用 plus.video.LivePusher，业务指南、规范文档 使用nvue做直播，比使用vue的优势有： nvue可一套代码直接编译到App和微信 nvue的cover-view比vue的cover-view更强大，在视频上绘制元素更容易。如果只考虑App端的话，不用cover-view，任意组件都可以覆盖live-pusher组件 若需要视频内嵌在swiper里上下滑动（类抖音、映客首页模式），App端只有nvue才能实现 当然nvue相比vue的坏处是css写法受限，如果只开发微信小程序，不考虑App，那么使用vue页面也是一样的。 参数说明 设置live-pusher组件的推流地址，推流视频模式等。 属性 类型 默认值 必填 说明 url string 是 推流地址，支持RTMP协议。 mode string 否 推流视频模式，可取值：SD（标清）, HD（高清）, FHD（超清）。 muted Boolean false 否 是否静音。 enable-camera Boolean true 否 开启摄像头。 auto-focus Boolean true 否 自动聚集。 beauty Number 0 否 美颜，取值范围 0-9（iOS取值范围为1） ，0 表示关闭。 whiteness Number 0 否 美白，取值范围 0-9（iOS取值范围为1） ，0 表示关闭。 API start(callback) 开始推流 callback 返回 Object 参数说明 属性 类型 说明 type String “success” 表示成功， “fail” 表示失败 pause(callback) 暂停推流 callback 返回 Object 参数说明 参数 类型 说明 type String “success” 表示成功， “fail” 表示失败 resume(callback) 恢复推流 callback 返回 Object 参数说明 参数 类型 说明 type String “success” 表示成功， “fail” 表示失败 stop(callback) 停止推流 callback 返回 Object 参数说明 参数 类型 说明 type String “success” 表示成功， “fail” 表示失败 switchCamera(callback) 切换前后摄像头 callback 返回 Object 参数说明 参数 类型 说明 type String “success” 表示成功， “fail” 表示失败 snapshot(callback) 快照 callback 返回 Object 参数说明 成功时的回调 参数 类型 说明 type string “success” 表示成功, “fail” 表示失败 code Number 对应code码 message object {width:”快照图片宽度”,height:”快照图片高度”,tempImagePath:”快照图片路径”}。 失败的回调 参数 类型 说明 type string “fail” 表示失败 code Number message object startPreview(callback) 开启摄像头预览 callback 返回 Object 参数说明 参数 类型 说明 type String “success” 表示成功， “fail” 表示失败 stopPreview(callback) 关闭摄像头预览 callback 返回 Object 参数说明 参数 类型 说明 type String “success” 表示成功， “fail” 表示失败 事件 statechange 状态变化事件 返回参数（detail）的详细说明 参数 类型 说明 code Number message string netstatus 网络状态通知事件 安卓 返回参数（detail）的详细说明 键名 说明 videoBitrate 当前视频编/码器输出的比特率，单位 kbps audioBitrate 当前音频编/码器输出的比特率，单位 kbps videoFPS 当前视频帧率 videoGOP 当前视频 GOP,也就是每两个关键帧(I帧)间隔时长，单位 s netSpeed 当前的发送/接收速度 netJitter 网络抖动情况，抖动越大，网络越不稳定 videoWidth 视频画面的宽度 videoHeight 视频画面的高度 iOS 返回参数（detail）的详细说明 参数 类型 说明 code Number code码 message string 具体的网络状态信息 error 渲染错误事件 返回参数（detail）的详细说明 参数 类型 说明 errCode Number errMsg string 5.背景音频播放管理uni.getBackgroundAudioManager()获取全局唯一的背景音频管理器 backgroundAudioManager。 背景音频，不是游戏的背景音乐，而是类似QQ音乐那样，App在后台时，仍然在播放音乐。如果你不需要在App切后台时继续播放，那么不应该使用本API，而应该使用普通音频APIuni.createInnerAudioContext。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 QQ小程序 √ x √ x √ √ √ backgroundAudioManager 对象的属性列表 属性 类型 说明 只读 duration Number 当前音频的长度（单位：s），只有在当前有合法的 src 时返回 是 currentTime Number 当前音频的播放位置（单位：s），只有在当前有合法的 src 时返回 是 paused Boolean 当前是是否暂停或停止状态，true 表示暂停或停止，false 表示正在播放 是 src String 音频的数据源，默认为空字符串，当设置了新的 src 时，会自动开始播放，目前支持的格式有 m4a, aac, mp3, wav 否 startTime Number 音频开始播放的位置（单位：s） 否 buffered Number 音频缓冲的时间点，仅保证当前播放时间点到此时间点内容已缓冲。 是 title String 音频标题，用于做原生音频播放器音频标题。原生音频播放器中的分享功能，分享出去的卡片标题，也将使用该值。 否 epname String 专辑名，原生音频播放器中的分享功能，分享出去的卡片简介，也将使用该值。 否 singer String 歌手名，原生音频播放器中的分享功能，分享出去的卡片简介，也将使用该值。 否 coverImgUrl String 封面图url，用于做原生音频播放器背景图。原生音频播放器中的分享功能，分享出去的卡片配图及背景也将使用该图。 否 webUrl String 页面链接，原生音频播放器中的分享功能，分享出去的卡片简介，也将使用该值。 否 protocol String 音频协议。默认值为 ‘http’，设置 ‘hls’ 可以支持播放 HLS 协议的直播音频，App平台暂不支持 否 backgroundAudioManager 对象的方法列表 方法 参数 说明 play 播放 pause 暂停 stop 停止 seek position 跳转到指定位置，单位 s onCanplay callback 背景音频进入可以播放状态，但不保证后面可以流畅播放 onPlay callback 背景音频播放事件 onPause callback 背景音频暂停事件 onStop callback 背景音频停止事件 onEnded callback 背景音频自然播放结束事件 onTimeUpdate callback 背景音频播放进度更新事件 onPrev callback 用户在系统音乐播放面板点击上一曲事件（iOS only） onNext callback 用户在系统音乐播放面板点击下一曲事件（iOS only） onError callback 背景音频播放错误事件 onWaiting callback 音频加载中事件，当音频因为数据不足，需要停下来加载时会触发 errCode 说明 errCode 说明 10001 系统错误 10002 网络错误 10003 文件错误 10004 格式错误 -1 未知错误 示例 12345const bgAudioMannager &#x3D; uni.getBackgroundAudioManager();bgAudioMannager.title &#x3D; &#39;致爱丽丝&#39;;bgAudioMannager.singer &#x3D; &#39;暂无&#39;;bgAudioMannager.coverImgUrl &#x3D; &#39;https:&#x2F;&#x2F;img-cdn-qiniu.dcloud.net.cn&#x2F;uniapp&#x2F;audio&#x2F;music.jpg&#39;;bgAudioMannager.src &#x3D; &#39;https:&#x2F;&#x2F;img-cdn-qiniu.dcloud.net.cn&#x2F;uniapp&#x2F;audio&#x2F;music.mp3&#39;; 注意 因为背景音频播放耗费手机电量，所以平台都有管控，需在manifest中填写申请。 ios App平台，背景播放需在manifest.json -&gt; app-plus -&gt; distribute -&gt; ios 节点添加 &quot;UIBackgroundModes&quot;:[&quot;audio&quot;] 才能保证音乐可以后台播放（打包成ipa生效） 小程序平台，需在manifest.json 对应的小程序节点下，填写”requiredBackgroundModes”: [“audio”]。发布小程序时平台会审核 Android App端默认不会在通知栏出现音量控制，如需此功能，需要在插件市场单独下载原生插件，详见","categories":[],"tags":[]},{"title":"TypeScript入门","slug":"TypeScript入门","date":"2020-10-11T13:45:03.000Z","updated":"2021-03-16T07:30:01.093Z","comments":true,"path":"posts/48922786/","link":"","permalink":"https://butterfly.js.org/posts/48922786/","excerpt":"","text":"一、 TypeScript 介绍 Typescript是由微软开发的一款开源的编程语言 Typescript是Javascript的超集，遵循最新的ES5/ES6规范。TypeScript扩展了Javascript语法 TypeScript更像后端Java、C#这样的面向对象语言可以让JS开发大型企业应用 谷歌也在大力支持TypeScript,谷歌的Angular2就是基于 TypeScript语法的 最新的Vue、React也可以集成Typescript. 二、TypeScript安装和编译安装12cnpm i typescript -gtsc helloworld.ts Vscode+TypeScript1234tsc --init&#123;&quot;outDir&quot;: &quot;.&#x2F;js&quot;&#125;Terminal - Run Task - tsc: watch - front&#x2F;tsconfig.json 三、数据类型布尔类型(boolean)1let married: boolean&#x3D;false; 数字类型(number)1let age: number&#x3D;10; 字符串类型(string)1let firstname: string&#x3D;&#39;zfpx&#39;; 数组类型(array)12let arr2: number[]&#x3D;[4,5,6];let arr3: Array&lt;number&gt;&#x3D;[7,8,9]; 元组类型(tuple)是数组类型中的一种 1let fullname: [string,string]&#x3D;[&#39;zhang&#39;,&#39;san&#39;]; 枚举类型(enum)事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值 比如性别、月份、星期、颜色、单位、学历 12js enum Gender&#123; GIRL, BOY &#125; console.log(李雷是$&#123;Gender.BOY&#125;); console.log(韩梅梅是$&#123;Gender.GIRL&#125;);enum Week&#123; MONDAY&#x3D;1, TUESDAY&#x3D;2 &#125; console.log(今天是星期$&#123;Week.MONDAY&#125;); 任意类型(any)12let root:any&#x3D;document.getElementById(&#39;root&#39;);root.style.color&#x3D;&#39;red&#39;; null 和 undefinednull 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined 12345678let x: number;x &#x3D; 1; &#x2F;&#x2F; 运行正确x &#x3D; undefined; &#x2F;&#x2F; 运行错误x &#x3D; null; &#x2F;&#x2F; 运行错误let y: number | null | undefined;y &#x3D; 1; &#x2F;&#x2F; 运行正确y &#x3D; undefined; &#x2F;&#x2F; 运行正确y &#x3D; null; &#x2F;&#x2F; 运行正确 void 类型void表示没有任何类型，一般用于定义方法的时候方法没有返回值 1234function greeting(name:string):void &#123; console.log(&#39;hello&#39;,name);&#125;greeting(&#39;zfpx&#39;); never类型never是其它类型(null undefined)的子类型，代表不会出现的值 12let x: never;x &#x3D; (()&#x3D;&gt;&#123; throw new Error(&#39;exception&#39;)&#125;)(); 四、函数函数的定义1234function hello(name:string):void &#123; console.log(&#39;hello&#39;,name);&#125;hello(&#39;zfpx&#39;); 没有返回值12345let hello2 &#x3D; function (name:string):void &#123; console.log(&#39;hello2&#39;,name);&#125;hello(&#39;zfpx&#39;);hello2(&#39;zfpx&#39;); 可选参数在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数 1234function print(name:string,age?:number):void &#123; console.log(name,age);&#125;print(&#39;zfpx&#39;); 默认参数1234function ajax(url:string,method:string&#x3D;&#39;GET&#39;) &#123; console.log(url,method);&#125;ajax(&#39;&#x2F;users&#39;); 剩余参数1234function sum(...numbers:number[]) &#123; return numbers.reduce((val,item)&#x3D;&gt;val+&#x3D;item,0);&#125;console.log(sum(1,2,3)); 函数重载 在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样 在TypeScript中，表现为给同一个函数提供多个函数类型定义 1234567891011121314let obj: any&#x3D;&#123;&#125;;function attr(val: string): void;function attr(val: number): void;function attr(val:any):void &#123; if (typeof val &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123; obj.age&#x3D;val; &#125; else &#123; obj.name&#x3D;val; &#125;&#125;attr(&#39;zfpx&#39;);attr(9);attr(true);console.log(obj); 作者：浪里行舟_前端工匠链接：https://www.imooc.com/article/276181","categories":[],"tags":[]},{"title":"为什么Vue中的slot不能应用v-show指令","slug":"为什么Vue中的slot不能应用v-show指令","date":"2020-09-18T02:15:02.000Z","updated":"2021-03-16T07:30:01.097Z","comments":true,"path":"posts/23b46ffc/","link":"","permalink":"https://butterfly.js.org/posts/23b46ffc/","excerpt":"","text":"今天偶然发现，在Vue中使用插槽slot，是无法通过v-show控制slot的显示的，来看代码 12345678910111213141516171819Vue.component(&#39;fade&#39;, &#123; props: [&#39;show&#39;], template: &#96; &lt;transition @before-enter&#x3D;&quot;handleBeforeEnter&quot; @enter&#x3D;&quot;handleEnter&quot;&gt; &lt;slot v-show&#x3D;&quot;show&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;transition&gt; &#96;, methods: &#123; handleBeforeEnter: function(el) &#123; el.style.color &#x3D; &#39;red&#39; &#125;, handleEnter: function(el, done) &#123; setTimeout(() &#x3D;&gt; &#123; el.style.color &#x3D; &#39;green&#39; done() &#125;, 2000) &#125; &#125; &#125;) 这是随便写的一个封装动画组件，如果在slot标签上使用v-show，程序功能是无法实现的，必须要改成v-if。 原因是这样的，slot实际上是一个抽象元素，有点类似template，本质上并不是一个元素。而v-show是通过控制元素的display来进行显示隐藏的，slot本质上并不是元素，所以压根也就不会有display 这个css属性。 所以，slot的显示隐藏，还真得使用v-if。 Vue的作者在社区内回答过这个问题，所以代码以这个答案为准即可。","categories":[],"tags":[]},{"title":"小程序搜索功能，云开发搜索，小程序云开发模糊搜索，同时搜索多个字段","slug":"小程序搜索功能，云开发搜索，小程序云开发模糊搜索，同时搜索多个字段","date":"2020-06-18T02:55:16.000Z","updated":"2021-03-16T07:30:01.100Z","comments":true,"path":"posts/53701062/","link":"","permalink":"https://butterfly.js.org/posts/53701062/","excerpt":"","text":"今天来给大家讲讲小程序的搜索功能。我这里后台数据库用的是小程序云开发的云数据库。所以我们搜索的时候就要借助云开发来实现。 一，需求比如我这里有如下的一些数据 我们想实现如下搜索需求 1，搜索标题(title)包含‘小石头’的数据 2，搜索标题(title)或者描述(desc)包含‘小石头’的数据 3，搜索标题(title)描述(desc)都包含‘小石头’的数据 我们知道数据库查询的时候有个where语句，但是where语句是查询某个字段全部包含你输入的内容时才可以，所以单纯用where语句来做搜索的话，结果太单一。所以我们今天就来学习下模糊搜索功能的实现。我们以上面三个需求为例，来一个个讲解。 二，实现原理我们做模糊搜索的时候，其实就是查询某个字段里是否包含我们的搜索词。而模糊搜索需要借助RegExp，来看看RegExp是什么。 再来看看官方示例 可能看官方示例会有点糊涂，那么我们接下来就结合具体代码来给大家做下讲解。 三，模糊搜索的代码实现3-1，模糊搜索单个字段 需求：搜索标题(title)包含‘小石头’的数据 代码如下 查询结果如下： 可以看到我们成功的查询到了标题里包含‘小石头的数据’ 3-2，模糊搜索多个字段（满足一个即可） 需求：搜索标题(title)或者描述(desc)包含‘小石头’的数据 由于我们要查询多个字段，所以我们这里用到了command高级操作符里的or 代码如下： 查询结果： 我们来分析下这两条数据 1，标题和描述都包含‘小石头’，符合 2，虽然标题里没有‘小石头’，但是描述里有，所以也符合。 3，title和desc里都没有‘小石头’，所以不符合。 3-3，模糊搜索多个字段（要同时满足） 需求：搜索标题(title)描述(desc)都包含‘小石头’的数据 由于我们要查询多个字段，所以我们这里用到了command高级操作符里的and 代码如下： 查询结果： 我们来分析下这两条数据 1，标题和描述都包含‘小石头’，符合 2，虽然desc里没有‘小石头’，但是title里没有，所以也不符合。 3，title和desc里都没有‘小石头’，所以也不符合。 四，源码为例方便大家使用，我把完整的代码贴到这里，后面大家使用时，直接复制这里的代码，略微改造下就可以了。 1234567891011121314151617181920212223242526&#x2F;&#x2F;我这里简单起见就把搜索词写死，正常应该用户输入的let searchKey &#x3D; &#39;小石头&#39;let db &#x3D; wx.cloud.database()let _ &#x3D; db.commanddb.collection(&#39;news&#39;) .where(_.or([ &#123;&#x2F;&#x2F;标题 title: db.RegExp(&#123; &#x2F;&#x2F;使用正则查询，实现对搜索的模糊查询 regexp: searchKey, options: &#39;i&#39;, &#x2F;&#x2F;大小写不区分 &#125;), &#125;, &#123;&#x2F;&#x2F;描述 desc: db.RegExp(&#123; regexp: searchKey, options: &#39;i&#39;, &#125;), &#125; ])).get() .then(res &#x3D;&gt; &#123; console.log(&#39;查询成功&#39;, res) &#125;) .catch(res &#x3D;&gt; &#123; console.log(&#39;查询失败&#39;, res) &#125;)","categories":[],"tags":[]},{"title":"小程序订阅消息","slug":"小程序订阅消息","date":"2020-05-25T02:03:14.000Z","updated":"2021-03-16T07:30:01.099Z","comments":true,"path":"posts/5d1df7f/","link":"","permalink":"https://butterfly.js.org/posts/5d1df7f/","excerpt":"","text":"小程序给用户推送消息原有方式是采用模板消息，用户通过表单生成formId来给推送消息，但小程序模板消息接口已于2020年1月10日下线，开发者可以使用另一种方式给用户推送消息：订阅消息。 请确认调试基础库的版本建议使用V2.8.2及以后版本 配置订阅消息模板首先确认确认当前小程序的id和登录的公众平台是不是同一个，因为之前经常有同学具有多个公众平台账号，有可能是多个账号会弄混导致模板消息发送失败。 在公众平台中配置模板消息，选择左边订阅消息菜单，然后点击右边添加按钮，根据自己需求选择消息模板 调起小程序订阅消息界面获取下发权限复制消息模板对应的模板ID，然后在小程序端调起订阅消息界面 1234567891011121314151617181920const templateId &#x3D; &#39;xxxxxx&#39;wx.requestSubscribeMessage(&#123; tmplIds: [templateId], success(res) &#123; if (res[templateId] &#x3D;&#x3D; &#39;accept&#39;) &#123; &#x2F;&#x2F;用户同意了订阅，允许订阅消息 wx.showToast(&#123; title: &#39;订阅成功&#39; &#125;) &#125; else &#123; &#x2F;&#x2F;用户拒绝了订阅，禁用订阅消息 wx.showToast(&#123; title: &#39;订阅失败&#39; &#125;) &#125; &#125;, fail(err) &#123; console.error(err) &#125;&#125;) 云函数端下发订阅消息12345678910111213141516171819202122232425262728try &#123; const wxContext &#x3D; cloud.getWXContext() const templateId &#x3D; &#39;xxxxxx return await cloud.openapi.subscribeMessage.send(&#123; touser: wxContext.OPENID, page: &#39;page&#x2F;index&#x2F;index&#39;, lang: &#39;zh_CN&#39;, data: &#123; phrase1: &#123; value: &#39;上课啦&#39; &#125;, thing2: &#123; value: &#39;小程序开发&#39; &#125;, thing3: &#123; value: &#39;订阅消息&#39; &#125; &#125;, templateId: templateId, miniprogramState: &#39;developer&#39; &#125;) console.log(result) return result &#125; catch (err) &#123; console.log(err) return err &#125; 设置订阅消息权限在当前云函数下面，新建config.json文件 1234567&#123; &quot;permissions&quot;: &#123; &quot;openapi&quot;: [ &quot;subscribeMessage.send&quot; ] &#125;&#125; 注意测试订阅消息需要在真机上测试，开发工具不能测试。点击真机调试，用手机扫描二维码可以测试。发送完消息以后，在微信页面的服务通知内，就能够看到推送的消息了。 代码参考https://github.com/xiecheng328/subscribeMessage 小程序开发学习建议 多看官方文档，小程序的官方文档写的非常的全面，涵盖了微信小程序开发的所有知识点，大家一定要多看微信小程序官方文档 多逛小程序开发社区，关于微信小程序的新功能以及更新内容都会在社区上面通知，大家遇到技术问题也可以在上面提问，会有微信团队官方工程师帮助我们解答 多敲代码，多练习。只有自己不断的练习才能真正的得到提高 分析问题和解决问题的能力。这是需要时间不断积累的，在遇到问题的时候，一定要多思考，对于有错误信息的问题一定要认真翻译错误信息，大多数的错误线索都能够被找到","categories":[],"tags":[]},{"title":"抄笔记：尤雨溪在Vue3.0 Beta直播里聊到了这些…","slug":"抄笔记：尤雨溪在Vue3-0-Beta直播里聊到了这些…","date":"2020-04-22T02:39:21.000Z","updated":"2021-03-16T07:30:01.103Z","comments":true,"path":"posts/7cff3812/","link":"","permalink":"https://butterfly.js.org/posts/7cff3812/","excerpt":"","text":"前言在 4 月 21 日晚，Vue 作者尤雨溪在哔哩哔哩直播分享了Vue.js 3.0 Beta最新进展。 1. 全新文档RFCs Vue.js 3.0 Beta发布后的工作重点是保证稳定性和推进各类库集成 所有的进度和文档都将在全新RFCs文档可以看到。 2. 六大亮点 Performance：性能更比Vue 2.0强。 Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。 Composition API：组合API Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念” Better TypeScript support：更优秀的 Ts 支持 Custom Renderer API：暴露了自定义渲染API 下面将按顺序分别描述。 3.Performance 重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。 编译模板的优化。 更高效的组件初始化。 update性能提高 1.3~2 倍。 SSR速度提高了 2~3 倍。 下面是各项性能对比 要点 1：编译模板的优化 假设要编译以下代码 1234&lt;div&gt; &lt;span&#x2F;&gt; &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 将会被编译成以下模样： 12345678910import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, null, &quot;static&quot;), _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.msg), 1 &#x2F;* TEXT *&#x2F;) ]))&#125;&#x2F;&#x2F; Check the console for the AST 注意看第二个_createVNode结尾的“1”： Vue 在运行时会生成number（大于 0）值的PatchFlag，用作标记。 仅带有PatchFlag标记的节点会被真正追踪，且无论层级嵌套多深，它的动态节点都直接与Block根节点绑定，无需再去遍历静态节点 再看以下例子： 1234&lt;div&gt; &lt;span&gt;static&lt;&#x2F;span&gt; &lt;span :id&#x3D;&quot;hello&quot; class&#x3D;&quot;bar&quot;&gt;&#123;&#123; msg &#125;&#125; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 会被编译成： 123456789101112import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, null, &quot;static&quot;), _createVNode(&quot;span&quot;, &#123; id: _ctx.hello, class: &quot;bar&quot; &#125;, _toDisplayString(_ctx.msg), 9 &#x2F;* TEXT, PROPS *&#x2F;, [&quot;id&quot;]) ]))&#125;PatchFlag&#96; 变成了&#96;9 &#x2F;* TEXT, PROPS *&#x2F;, [&quot;id&quot;] 它会告知我们不光有TEXT变化，还有PROPS变化（id） 这样既跳出了virtual dom性能的瓶颈，又保留了可以手写render的灵活性。等于是：既有react的灵活性，又有基于模板的性能保证。 要点 2: 事件监听缓存：cacheHandlers假设我们要绑定一个事件： 12345&lt;div&gt; &lt;span @click&#x3D;&quot;onClick&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 关闭cacheHandlers后： 1234567import &#123; toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, &#123; onClick: _ctx.onClick &#125;, _toDisplayString(_ctx.msg), 9 &#x2F;* TEXT, PROPS *&#x2F;, [&quot;onClick&quot;]) ]))&#125; onClick会被视为PROPS动态绑定，后续替换点击事件时需要进行更新。 开启cacheHandlers后： 123456789import &#123; toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, &#123; onClick: _cache[1] || (_cache[1] &#x3D; $event &#x3D;&gt; (_ctx.onClick($event))) &#125;, _toDisplayString(_ctx.msg), 1 &#x2F;* TEXT *&#x2F;) ]))&#125; cache[1]，会自动生成并缓存一个内联函数，“神奇”的变为一个静态节点。Ps：相当于React中useCallback自动化。 并且支持手写内联函数： 12345&lt;div&gt; &lt;span @click&#x3D;&quot;()&#x3D;&gt;foo()&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 4. Tree shaking support 可以将无用模块“剪辑”，仅打包需要的（比如v-model,&lt;transition&gt;，用不到就不会打包）。 一个简单“HelloWorld”大小仅为：13.5kb 11.75kb，仅Composition API。 包含运行时完整功能：22.5kb 拥有更多的功能，却比Vue 2更迷你。 很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入。 5. Composition API与React Hooks 类似的东西，实现方式不同。 可与现有的 Options API一起使用 灵活的逻辑组合与复用 vue 3的响应式模块可以和其他框架搭配使用 混入(mixin) 将不再作为推荐使用， Composition API可以实现更灵活且无副作用的复用代码。 感兴趣的可以查看：https://composition-api.vuejs.org/#summary 1Composition API&#96;包含了六个主要&#96;API 可以到这里查看：https://composition-api.vuejs.org/api.html#setup Ps：其它的均为常见的工具函数，可先忽略不看。 6. Fragment Fragment翻译为：“碎片” 不再限于模板中的单个根节点 render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。 ‘Just works’ 6.1 &lt;Teleport&gt; 以前称为&lt;Portal&gt;，译作传送门。 更多细节将由@Linusborg 分享 &lt;Teleport&gt;原先是对标 React Portal（增加多个新功能，更强） 但因为Chrome有个提案，会增加一个名为Portal的原生element，为避免命名冲突，改为Teleport 6.2 &lt;Suspense&gt; Suspense翻译为：“悬念” 可在嵌套层级中等待嵌套的异步依赖项 支持async setup() 支持异步组件 虽然React 16引入了Suspense，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。 Vue 3 的&lt;Suspense&gt;更加轻量： 仅 5%应用能感知运行时的调度差异，综合考虑下，Vue3 的&lt;Suspense&gt; 没和 React 一样做运行调度处理 7. 更好的TypeScript支持 Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示 JavaScript和TypeScript中的 API 是相同的。 事实上，代码也基本相同 支持TSX class组件还会继续支持，但是需要引入vue-class-component@next，该模块目前还处在 alpha 阶段。 还有Vue 3 + TypeScript 插件正在开发，有类型检查，自动补全等功能。目前进展可喜。 8. Custom Renderer API：自定义渲染器 API 正在进行NativeScript Vue集成 用户可以尝试WebGL自定义渲染器，与普通 Vue 应用程序一起使用（Vugel）。 意味着以后可以通过 vue， Dom 编程的方式来进行 webgl 编程 。感兴趣可以看这里：Getting started vugel 9. 剩余工作 9.1 Docs &amp; Migration Guides 新的文档编写交由@NataliaTepluhina, @sdras, @bencodezen &amp; @phanan 负责 @sdras 正在做自动升级迁移工具 @sodatea 已经开始研究CodeMods 9.2 Router 下一代 Router：vue-router@next已在alpha阶段，感谢@posva 有部分的API变动，可到RFC上看。 9.3 Vuex` 下一代Vuex：，vuex@next（与Vue 3 compat相同的 API），已在alpha阶段，感谢@KiaKing。 团队正在为下一次迭代试验Vuex API的简化 目前以兼容Vue 3为主，基本上没有API变动，莫慌。 9.4 CLI CLI插件：vue-cli-plugin-vue-nextby @sodatea （wip）CodeMods支持升级Vue 2应用 9.5 新工具：vite（法语 “快”）地址：https://github.com/vuejs/vite 一个简易的http服务器，无需webpack编译打包，根据请求的Vue文件，直接发回渲染，且支持热更新（非常快） 9.6 vue-test-utils 下一代test-utils:test-utils@next by @lmiller1990, @dobromir-hristov, @afontcu &amp; @JessicaSachs 9.7 DevTools 早期的原型已经由@Akryum 完成，当我们到beta时，将完全集成。 目前需要花更多精力去完善。 9.8 IDE Support (Vetur) @znck目前正在试验模板的类型检查 @octref将在 5 月为Vue 3进行Vetur集成 9.9 Nuxt 目前Nuxt的整合工作也正在进行中，内部团队已经跑起来了。还需要时间磨合 10 Vue 2.x还有 2.7 版本 将有最后一个小版本（2.7） 从Vue 3向后移植兼容的改进(不损坏兼容性前提下) 加上在Vue 3中删除的功能的弃用警告 LTS1 18 个月。 最后建议：Vue 3虽好，如果你的项目很稳定，且对新功能无过多的要求或者迁移成本过高，则不建议升级。 结束花了一宿反复回放整理出来的，如有错误，尽情谅解。 附：直播中用到的渲染模板查看工具地址：https://vue-next-template-explorer.netlify.app/","categories":[],"tags":[]},{"title":"微信小程序云开发","slug":"微信小程序云开发","date":"2020-04-12T01:28:32.000Z","updated":"2021-03-16T07:30:01.102Z","comments":true,"path":"posts/5a55758b/","link":"","permalink":"https://butterfly.js.org/posts/5a55758b/","excerpt":"","text":"微信小程序开发已经成为目前最火爆的技能之一，无论是在求职、毕设、兴趣培养等方面都已经成为一项必备技能，而小程序云开发技术的出现更是点燃了整个小程序生态圈。在2019微信公开课PRO小程序分论坛上，腾讯云宣布推出总价值超过10 亿元的“小程序·云开发”资源扶持计划，对超过一百万个小程序开发者提供免费资源扶持，全面助力开发者通过云开发打造优秀的微信小程序。这是继与微信团队联合推出降低开发门槛的“小程序·云开发”产品后，腾讯云在小程序开发成本上再次面向开发者释放红利。那么什么是小程序云开发呢？我们通过对比云开发模式与传统开发模式之间的区别，来解释什么是小程序的云开发。 小程序云开发与传统开发模式区别？小程序传统开发模式 开发效率低： 大多数小程序所展示的数据都应该不是在页面上写死的，所以大多数小程序都需要一个服务端，服务端可以用多种技术实现，如PHP、Node.js、Java等。不管使用哪种技术实现服务端，开发一款小程序一般情况下都需要至少配备两个程序员，一个开发小程序前端，一个开发小程序服务端，这样的话这两个程序员之间就需要不断沟通，确认共同遵循的接口。可沟通过程中往往权责不清晰，有很多临界的位置，谁管都可以，容易引发扯皮，沟通成本非常高，导致开发效率下降。同时，由于开发人员的增多，整个开发的成本也会提高。这也是困扰着很多创业型公司的问题。 维护成本高： 项目上线的时候，公司需要自己搭建服务，不仅要花大价钱买机器、买宽带流量，还得请专门的人员去维护。运维人员需要考虑比如数据库运维，文件存储、内容加速、网络防护、容器服务、负载均衡、安全加固等等一系列的问题，这在公司里面是很头疼的一件事。 小程序云开发模式小程序云开发是腾讯云和微信团队联合开发的，集成于小程序控制台的原生 Serverless 云服务，为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。只需要一名开发人员就可以完成所有的工作。云开发核心能力包括：云存储、云数据库、云函数、云调用、HTTP API。 区别对比传统开发模式 开发效率低：过多的非业务逻辑需要处理，导致开发效率难以提升 资源投入高：无论是物理机托管，还是云主机维护，都需要较多的人力物力投入 产品上线慢：前后端联调、资源存储、部署等操作繁杂，上线流程耗时长 日常运维难：需时刻关注环境运行状况，管理相关资源，运维难度大 云开发模式 高效开发：只需编写核心逻辑代码，内建小程序用户鉴权，无需关注后端配置与部署，专注于业务开发 节约成本：按请求数和资源的运行收费，极大节约时间和成本，提供一定量免费额度使用 官方生态：原生集成微信SDK，云相关API开箱即用；同时，通过云调用，可免鉴权直接调用微信开放接口 稳定可靠：底层资源由腾讯云提供专业支持，满足不同业务场景和需求，具备快速拓展能力，确保服务稳定，数据安全 前端热词Serverless​ 在2019年，前端有一个很火的热词，叫做Serverless，server就是服务，less更少的，翻译过来就是无服务开发，而小程序云开发是这种无服务的开发。举个更形象的例子，比如我们想开一场演唱会，之前的做法是需要自己联系场地、灯光、伴奏，而有了云开发以后，相当于是演唱会需要的所有东西都有人帮我们准备好了，我们只需要站在舞台上演唱就可以。 Serverless中有一个概念，叫做 函数即服务，我们在使用云开发来实现小程序后端服务的时候，可以直接调用函数即可，对前端来说，后端服务就是一个函数，整个小程序的前后端逻辑都能在一个IDE里面完成，用户其实完全不用担心到底哪些是服务器的逻辑，后端服务和前端完全的融合在一种代码体系里去了，这样后端的服务即是一个函数，至于这个函数是在前端实现，或者是在后端很远的地方实现，开发者都可以不用关心。所以说，severless打破了物理隔离。开发者不再去做任何隔离中间层的事前，我只需要关心函数的实现就可以了。 所以这种开发模式可以实现真正的全栈技术开发，这对现有的开发模式是一个很大的革新。 小程序云开发优势 快速上线项目：快速上线对于公司是非常必要的。很多公司可能已经具备了自己的网站或者APP，但现在小程序如此火爆所以想开发一款小程序，那么小程序·云开发可以帮助你在最短时间上线应用，完成快速试错 专注核心业务，放弃非核心逻辑：使用云开发以后，你只需编写最重要的“核心代码”，不再需要关心周边组件，极大地降低了服务架构搭建的复杂性，成本更低 你可以独自完成一个小程序的设计、开发、发布：在传统的开发模式下，你需要一个后端开发者来配合你完成整个小程序的开发。在小程序·云开发中，你只需要借助云开发提供的丰富的 API ，就可以实现数据的存储、文件的上传、结果的计算，大大的提升了工作的效率 你无需学习一门新的语言：小程序·云开发目前支持 Node.js ，和进行小程序开发时使用的 JavaScript 同出一门，你可以以更低的学习成本来完成小程序的开发 你无需关注系统运维：当应用上线后，运维就成为了一个大的问题，当海量流量来袭时，如何快速调整系统容量，确保业务的稳步运行就成为了一个问题。当你使用云开发后，云开发将为你接管运维层面的事务，让你更加关注应用本身 弹性伸缩：在传统的单体开发模式中，应用需要以应用、站点为单位进行伸缩，因为我们的开发是基于整个应用、整个站点进行开发，无法单独对某一个特定的功能进行伸缩。而云开发所采用的 Serverless 方案中的运算部分，是交给云函数来进行处理的，你的应用由一个个函数组成的，因此，在弹性伸缩方面，粒度进一步细化，针对特定功能的函数来进行伸缩，弹性效率更高，能够承载的请求量更大 数据安全：在云开发模式下，每个用户的环境资源是独立的，也即是私有的，并且云开发提供与自有数据库打通的能力。这样，用户的数据都存在用户自己的云开发环境资源下面，一定层面保障了用户的数据安全与稳定性 开通云开发 下载微信开发者工具并安装：下载地址 新建项目，后端服务选择小程序云开发 新建项目后，点击开发工具上方云开发按钮! 点击开通按钮 填入环境名称，图中的基础配额完全都是免费的 点击确定，开通云开发 开通以后，官方给出从时间是十分钟左右就可以开通成功，实际测试其实很快 云开发提供的五大能力1.云函数一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。小程序内提供了专门用于云函数调用的 API。开发者可以在云函数内获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。开放了运用 Node.js 等框架编写“后端”业务逻辑后，直接可以部署在云平台下，完全不需要去考虑域名、服务器、打包发布、运维等等琐事 2.云数据库云开发提供了一个 JSON 数据库，顾名思义，数据库中的每条记录都是一个 JSON 格式的对象。一个数据库可以有多个集合（相当于关系型数据中的表），集合可看做一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 对象。这样的话，数据库的存储也不用考虑了，直接提供了一个类似于 MongoDB一样的数据库，而且免费的存储空间达到了 2G，一般的项目足够使用了 3.云存储云开发提供了一块文件存储空间，提供了上传文件到云端、带权限管理的云端下载能力，开发者可以在小程序端和云函数端通过 API 使用云文件存储功能。在小程序端可以分别调用 wx.cloud.uploadFile 和 wx.cloud.downloadFile 完成上传和下载云文件操作。这就相当于腾讯直接给你提供了一个静态文件的 CDN，免费的容量直接达到了 5G，一般项目前期是够用的 4.云调用云调用是云开发提供的基于云函数使用小程序开放接口的能力，支持在云函数调用服务端开放接口，如发送模板消息、获取小程序码等操作都可以在云函数中完成 5.HTTP API云开发资源也可以通过 HTTP 接口访问，即在小程序外访问。比如你的小程序项目，需要做一个后台管理系统对小程序中的数据和文件进行管理，就可以使用HTTP API来访问云开发当中的资源 小程序开发适合人群 打算进入职场，从事前端开发甚至是全栈开发的职场小白 已经有了一定的前端工作经验，但由于公司业务需要，打算学习小程序开发的技能党 正在做毕业设计并且想做出精品高质量毕设项目的学生党 看到小程序开发如此火爆，打算一起尝鲜的达人 小程序可发学习建议 多看官方文档，小程序的官方文档写的非常的全面，涵盖了微信小程序开发的所有知识点，大家一定要多看微信小程序官方文档 多逛小程序开发社区，关于微信小程序的新功能以及更新内容都会在社区上面通知，大家遇到技术问题也可以在上面提问，会有微信团队官方工程师帮助我们解答 多敲代码，多练习。只有自己不断的练习才能真正的得到提高 分析问题和解决问题的能力。这是需要时间不断积累的，在遇到问题的时候，一定要多思考，对于有错误信息的问题一定要认真翻译错误信息，大多数的错误线索都能够被找到","categories":[],"tags":[]}],"categories":[],"tags":[]}